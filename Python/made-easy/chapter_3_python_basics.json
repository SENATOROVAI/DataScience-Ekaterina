{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\"\"\"Основы Python.\"\"\""
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Основы Python\n",
    "\n",
    "3.1. Запуск Python\n",
    "3.1.1. Использование Spyder IDE\n",
    "Интегрированная среда разработки Spyder имеет свой графический интерфейс. \n",
    "Сначала откройте Anaconda Navigator.\n",
    "Нажмите кнопку Launch под приложением Spyder. Откроется первое окно Spyder\n",
    "IDE со временным файлом.\n",
    "Для начала изучения нам понадобятся три основных компонента Spyder IDE:\n",
    "♦ Редактор. \n",
    "Редактор Spyder во многих отношениях лучше простого текстового редактора.\n",
    "Помните, что это IDE, и, следовательно, ее функционал гораздо шире\n",
    "и включает в себя, например, нумерацию строк, выделение синтаксиса (ключе-\n",
    "вые слова в синтаксисе подсвечиваются цветом), функции автозаполнения и\n",
    "многое другое. В этом многоязычном редакторе вы можете эффективно работать\n",
    "с функциями и классами, пользоваться инструментами анализа кода, автомати-\n",
    "ческим завершением кода, горизонтальным/вертикальным разделением и пере-\n",
    "ходом к определению объекта.\n",
    "♦ Консоль IPython. \n",
    "Вам доступны возможности любого количества консолей I Python в сочетании\n",
    "с гибкостью графического интерфейса. Вы можете запускать код по строкам, \n",
    "ячейкам или файлам, а также отображать графики прямо в строке.\n",
    "♦ Обозреватель переменных. \n",
    "Этот компонент позволяет взаимодействовать с переменными и изменять их \n",
    "на лету, строить гистограмму или временной ряд, редактировать датафреймы\n",
    "или массивы NumPy, сортировать коллекции, копаться во вложенных объектах\n",
    "и многое другое.\n",
    "Если говорить просто, то в редакторе мы что-то пишем (в том числе код). \n",
    "Консоль IPython - это окно консоли, подобное командной строке, в котором \n",
    "выводятся результаты выполнения кода и которое можно использовать независимо\n",
    "от редактора. В окне обозревателя переменных отображаются создаваемые \n",
    "объекты: новые переменные, классы, фреймы данных, диаграммы, графики и т. д.\n",
    "3.1.2. Использование Jupyter Notebook\n",
    "Jupyter Notebook также входит в состав Anaconda, поэтому снова откройте окно\n",
    "Anaconda Navigator. Нажмите кнопку Launch под приложением Jupyter Notebook.\n",
    "Стартовое окно Jupyter Notebook откроется в браузере, который установлен по\n",
    "умолчанию. Чтобы создать документ Notebook, нажмите на кнопку New в правом\n",
    "верхнем углу и выберите пункт меню Python 3.  Откроется новая веб-страница \n",
    "с одной пустой ячейкой и без имени. Теперь вы можете добавлять в документ\n",
    "любое количество ячеек, удалять их, изменять порядок отображения и многое\n",
    "другое. Чтобы запустить строку кода, просто введите ее в ячейку, оставьте\n",
    "тип ячейки Code (который задан по умолчанию) и используйте любой из способов\n",
    "запуска:\n",
    "♦ с помощью мыши - откройте пункт меню Cell. Используйте любой из вариан-\n",
    "тов запуска, какой вам подходит;\n",
    "♦ с помощью клавиаrуры - к пунктам меню Cell можно обращаться с помощью\n",
    "горячих клавиш. Вот три наиболее часто используемых сочетания клавиш для\n",
    "запуска кода:\n",
    "• <Shift>+<Enter> - запустить ячейку и перейти к следующей;\n",
    "• <Ctrl>+<Enter> - запустить выбранные ячейки;\n",
    "• <Alt>+<Enter> - запустить ячейку и вставить новую ниже.\n",
    "\n",
    "3.2. Начнем с «Hello World!»\n",
    "Давайте продолжим традицию изучать компьютерное программирование прове\n",
    "ренным поколениями методом - с помощью «Hello World!».\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Hello World!\n"
     ]
    }
   ],
   "source": [
    "print(\"Hello World!\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "3.3. Использование Python как калькулятора.\n",
    "Интерпретатор Python можно использовать как простой калькулятор: мы вводим\n",
    "в него выражение, а он возвращает значение. Синтаксис выражений прост: арифме-\n",
    "тические операторы +, -, * и / работают так же, как в любой компьютерной про-\n",
    "грамме, которую вы могли использовать, например, в цифровом калькуляторе или\n",
    "электронной таблице Excel; круглые скобки ( ) , как обычно, могут использоваться\n",
    "для группировки. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "4"
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "2 + 2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "20"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "50 - 5 * 6"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "5.0"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "(50 - 5 * 6) / 4"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "1.6"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "8 / 5  # результат деления всегда с плавающей точкой"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Целые числа (например, 2, 4, 20) имеют тип int, а числа с дробной частью \n",
    "(например, 5.0, 1.6) имеют тип float. Оператор деления / всегда возвращает\n",
    "float. Чтобы выполнить деление нацело и получить целочисленный результат\n",
    "(отбрасив дробную часть), вы можете использовать оператор //, а для \n",
    "вычисления остатка - оператор %."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "5.666666666666667"
      ]
     },
     "execution_count": 8,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "17 / 3  # обычное деление с плавающей точкой"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "5"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "17 // 3  # целочисленное деление"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "2"
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "17 % 3  # остаток от деления"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "17"
      ]
     },
     "execution_count": 11,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "5 * 3 + 2  # проверка : результат * делитель + остаток"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Для вычисления степени можно использовать оператор ** ."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "25"
      ]
     },
     "execution_count": 12,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "5**2  # 5 в квадрате"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "128"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "2**7  # 2 в степени 7"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Знак равенства = используется для присвоения значения переменной. После при\n",
    "своения результат не отображается:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "900\n"
     ]
    }
   ],
   "source": [
    "width = 20\n",
    "height = 5 * 9\n",
    "# обратите внимание, что этот код ничего не возвращает\n",
    "\n",
    "print(width * height)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "3.3.2. Строки\n",
    "Помимо чисел Python может также работать со строками, которые можно задавать\n",
    "несколькими способами. Они могут быть заключены в одинарные ' . . . ' или \n",
    "двойные кавычки \" . . . \". Для экранирования кавычек используется символ \\ :"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'python string'"
      ]
     },
     "execution_count": 15,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "print(\"python string\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "\"doesn't\""
      ]
     },
     "execution_count": 16,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "print(\"doesn't\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "\"doesп ' t\""
      ]
     },
     "execution_count": 17,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "print(\"doesп ' t\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "В интерактивном интерпретаторе строка вывода заключается в кавычки, а специ-\n",
    "альные символы экранированы обратной косой чертой. Функция print ( ) позволяет\n",
    "получить более читаемый вывод, опустить кавычки и вывести экранированные и\n",
    "специальные символы:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'\"Isn\\' t,\" they said.'"
      ]
     },
     "execution_count": 18,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "print('\"Isn\\' t,\" they said.')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\"Isn't,\" they said.\n"
     ]
    }
   ],
   "source": [
    "print('\"Isn\\'t,\" they said.')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Если вы не хотите, чтобы управляющие символы (такие как \\n, \\t) \n",
    "интерпретировались как специальные, вы можете использовать необработанные\n",
    "строки, добавив букву r перед первой кавычкой:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "C:\\some\n",
      "ame\n"
     ]
    }
   ],
   "source": [
    "print(\"C:\\\\some\\name\")  # здесь \\n - переход на новую строку!"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "C:\\some\\name\n"
     ]
    }
   ],
   "source": [
    "print(r\"C:\\some\" + r\"\\name\")\n",
    "# r перед открывающей кавычкой"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "3.3.2.1. Конкатенация и повторение\n",
    "Строки можно объединять (склеивать) с помощью оператора + и повторять с \n",
    "помощью оператора *. Запомнить это просто. Оператор + складывает, а \n",
    "* умножает."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'ab'"
      ]
     },
     "execution_count": 26,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"a\" + \"b\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'ttttt'"
      ]
     },
     "execution_count": 27,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"t\" * 5"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'nononodip'"
      ]
     },
     "execution_count": 28,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"no\" * 3 + \"dip\""
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Два или более строковых литерала (заключенных в кавычки строки), \n",
    "расположенных рядом друг с другом, автоматически объединяются."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "nilabh\n"
     ]
    }
   ],
   "source": [
    "print(\"nil\" + \"abh\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Это особенно удобно, если требуется разделить длинные строки."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'Put several strings within parentheses -to have them joined together.'"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "text_1 = \"Put several strings within parentheses -\"\n",
    "text_2 = \"to have them joined together.\"\n",
    "text = text_1 + text_2\n",
    "text"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "3.3.2.2. Индексирование\n",
    "Строки можно индексировать (обращаться к элементам строки по индексу), при\n",
    "этом первый символ имеет индекс О. Отдельного типа для данных символов не\n",
    "существует, т.к. символ - это просто строка длиной в один символ."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'P'"
      ]
     },
     "execution_count": 39,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "word = \"Python\"\n",
    "word[0]  # символ в позиции О"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'n'"
      ]
     },
     "execution_count": 40,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "word[5]  # символ в позиции 5"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 41,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'t'"
      ]
     },
     "execution_count": 41,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "word[-4]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "3.3.2.3. Срезы\n",
    "Помимо индексирования строк также поддерживаются срезы. Если индексирование\n",
    "используется для извлечения отдельных символов, то срез возвращает подстроку."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'Py'"
      ]
     },
     "execution_count": 42,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "word[0:2]  # с позиции О (включительно) до 2 (не включая его)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'thon'"
      ]
     },
     "execution_count": 43,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "word[2:]  # с позиции 2 (включительно) до 5 (не включая его)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Обратите внимание, что начальный индекс всегда включается, а конечный всегда\n",
    "исключается. Это гарантирует, что s [:i] + s [i:] всегда равно s."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 44,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'Python'"
      ]
     },
     "execution_count": 44,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "word[:2] + word[2:]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "У срезов есть полезные значения по умолчанию для индексов. Опущенный первый\n",
    "индекс по умолчанию равен нулю, опущенный второй индекс по умолчанию равен\n",
    "длине строки.\n",
    "Строки Python нельзя изменить - они неизменяемы. Следовательно, присвоить\n",
    "новое значение символу по определенному индексу нельзя. Если вы попытаетесь\n",
    "это сделать, получите ошибку:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "word[2] = 'l'"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "3.4. Синтаксис кода Python\n",
    "3.4.1. Выражения\n",
    "Строки, написанные в исходном коде для выполнения, называются выражениями,\n",
    "которые могут состоять из операторов разных типов, таких как оператор\n",
    "присваивания, условный оператор, оператор цикла и т. д. Все они нужны для того,\n",
    "чтобы пользователь мог получить нужный результат. Например, n = 20 - это вы\n",
    "ражение с оператором присваивания.Выражения могут быть однострочными или \n",
    "многострочными. Многострочные выражения можно переносить на другие строки с \n",
    "помощью круглых скобок ( ), фигурных скобок { }, квадратных скобок [],\n",
    "обратной косой черты (\\)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "45"
      ]
     },
     "execution_count": 2,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# перенос выражения на новую строку с использованием \\\n",
    "s_ = 1 + 2 + 3 + 4 + +5 + 6 + 7 + 8 + 9\n",
    "s_"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "30"
      ]
     },
     "execution_count": 55,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# перенос выражения на новую строку с использованием ( )\n",
    "n_ = 1 * 2 * 3 + 7 + 8 + 9\n",
    "n_"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 51,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['МESSI', 'NEYMAR', 'SUAREZ']"
      ]
     },
     "execution_count": 51,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# перенос выражения на новую строку с использованием [ ]\n",
    "footballer = [\"МESSI\", \"NEYMAR\", \"SUAREZ\"]\n",
    "footballer"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{45}"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# перенос выражения на новую строку с использованием { }\n",
    "x_ = {1 + 2 + 3 + 4 + +5 + 6 + 7 + 8 + 9}\n",
    "x_"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "3.4.1.1 . Окончание выражений\n",
    "В Python конец строки означает конец выражения. \n",
    "Можно также завершить выражение с помощью точки с запятой (;). Иногда за счет\n",
    "этого можно размещать нескольких выражений в одной строке, например:\n",
    "flag = 2 ; ropes = 3; pole = 4\n",
    "3.4.2. Переменные и присваивание значений\n",
    "Одна из самых мощных функциональностей любого языка программирования -\n",
    "это возможность работать с переменными. Переменная - это некоторое имя, свя-\n",
    "занное со значением. Обратите внимание, что переменная лишь ссылается на зна-\n",
    "чение, которое ей присвоено, но не тождественна ему. Когда переменной присваи-\n",
    "вается другое значение, старое присвоение сразу становится недействительным.\n",
    "Оператор присваивания позволяет автоматически создавать новые переменные\n",
    "и присваивать им значения:\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 62,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "45\n"
     ]
    }
   ],
   "source": [
    "# переменной а присваиваем значение 45\n",
    "a_ = 45\n",
    "# и выводим значение переменной на экран\n",
    "print(a_)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 64,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "5\n"
     ]
    }
   ],
   "source": [
    "# присваиваем той же переменной другое значение\n",
    "a_ = 3 + 2\n",
    "5\n",
    "# и снова выводим\n",
    "print(a_)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "3.4.3. Имена переменных и ключевые слова\n",
    "Для переменных следует выбирать имена со смыслом, которые что-то говорят\n",
    "о хранимых данных. Например, при работе с данными о продажах магазина в вы\n",
    "ходные подойдет имя переменной Sales_weekend. Это не строгое правило, но его\n",
    "соблюдение очень важно для обеспечения читабельности кода. \n",
    "Имена переменных могут быть любой длины и содержать как буквы, так и числа.\n",
    "Писать имена можно в верхнем или нижнем регистре, но одно и то же имя с раз-\n",
    "ными регистрами - это будут разные переменные, т.к. Python чувствителен к ре-\n",
    "гистру. Существует еще несколько правил именования переменных.\n",
    "♦ Имя должно начинаться с буквы (не с цифры).\n",
    "♦ В имени может присутствовать символ подчеркивания (_). Он используется для\n",
    "соединения слов в длинном имени переменной, т.к. пробелы использовать\n",
    "нельзя.\n",
    "♦ Нельзя использовать в качестве имен переменных ключевые слова Python:\n",
    "and def ехес if not return\n",
    "assert del finally import or try\n",
    "break elif for in pass while\n",
    "class else from is print yield\n",
    "continue except global lamЬda raise\n",
    "Назначив переменной недопустимое имя, вы получите синтаксическую ошибку.\n",
    "\n",
    "3.4.4. Выполнение выражений\n",
    "Выражение - это совокупность значений, переменных и операторов. Когда в ы\n",
    "вводите в командной строке выражение, интерпретатор вычисляет его и выводит\n",
    "результат."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 65,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "5"
      ]
     },
     "execution_count": 65,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "2 + 3"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Выражения могут содержать значения, переменные и операторы, но не обязательно\n",
    "все их сразу. Само по себе значение тоже считается выражением, как и отдельно\n",
    "взятая переменная."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 67,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "15"
      ]
     },
     "execution_count": 67,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "15"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 68,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "5"
      ]
     },
     "execution_count": 68,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "a_"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Когда интерпретатор Python выводит значение выражения, он использует тот же\n",
    "формат, который вы использовали бы для ввода значения. Для строк это означает,\n",
    "что будут выведены кавычки. Но если вы используете функцию print ( ) , Python\n",
    "отображает содержимое строки без кавычек."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "3.5. Первые шаги в программировании"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0\n",
      "1\n",
      "1\n",
      "2\n",
      "3\n",
      "5\n",
      "8\n"
     ]
    }
   ],
   "source": [
    "# ряд Фибоначчи\n",
    "# сумма двух элементов -- это следующий элемент ряда\n",
    "a_ = 0\n",
    "b_ = 1\n",
    "while a_ < 10:\n",
    "    print(a_)\n",
    "    a_, b_ = b_, a_ + b_"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 70,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0\n",
      "1\n",
      "1\n",
      "2\n",
      "3\n",
      "5\n",
      "8\n",
      "13\n"
     ]
    }
   ],
   "source": [
    "a_, b_ = 0, 1\n",
    "while a_ < 15:\n",
    "    print(a_)\n",
    "    a_, b_ = b_, a_ + b_"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "1. В первой строке используется множественное присваивание: переменные а и ь\n",
    "одновременно получают значения о и 1. В последней строке кода это использу-\n",
    "ется снова, причем здесь важно, что перед таким присваиванием всегда сначала\n",
    "вычисляется правая часть. Выражения в правой части вычисляются слева на\n",
    "право.\n",
    "2. Цикл while выполняется до тех пор, пока условие остается истинным (в первом\n",
    "варианте это было а < 1 0, которое мы позже изменили на а < 15). В Python ис-\n",
    "тинным является любое ненулевое целочисленное значение, ноль считается\n",
    "ложным. Условие также может быть строкой или списком и вообще любой по-\n",
    "следовательностью. При этом все, что имеет ненулевую длину, считается истин-\n",
    "ным, а пустые последовательности - ложными. Условие, использованное в нашем\n",
    "примере, представляет собой простое сравнение. \n",
    "3. Тело цикла записано с отступом. Отступы - это способ группировки выраже-\n",
    "ний в Python. В интерактивном режиме интерпретатора для задания отступа\n",
    "нужно использовать табуляцию или пробелы. На практике код бывает гораздо\n",
    "более сложным, и у всех специализированных текстовых редакторов есть функ-\n",
    "ция автоматического отступа. Когда составное выражение вводится в интерак-\n",
    "тивном режиме, за ним должна следовать пустая строка, указывающая на завер-\n",
    "шение (поскольку синтаксический анализатор не может угадать, когда блок кода\n",
    "закончился). Обратите внимание, что у всех строк в блоке должен быть одина-\n",
    "ковый отступ.\n",
    "4. Функция print ( ) выводит значение переданного аргумента на экран. Ее работа\n",
    "отличается от простого написания выражения в строке (как мы делали ранее),\n",
    "т.к. эта функция по-другому обрабатывает несколько аргументов, числа с пла-\n",
    "вающей запятой и строки. Строки выводятся без кавычек, а между аргументами\n",
    "вставляется пробел, что позволяет красиво форматировать результаты:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 71,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The value of i is  65536\n"
     ]
    }
   ],
   "source": [
    "i_ = 256 * 256\n",
    "print(\"The value of i is \", i_)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "3.5.1. Подробнее о функции print()\n",
    "Фактический синтаксис функции print ( ) выглядит так:\n",
    "print ( *obj ects, sep= ' ' , end= ' \\n ' , file=sys . stdout, flush=False)\n",
    "Две важные концепции программирования на Python:\n",
    "♦ Аргументы (иногда обозначаемые словом args);\n",
    "♦ Именованные аргументы (иногда обозначаемые словом kwargs).\n",
    "\n",
    "Аргументы - это все, что мы передаем в функцию. Например, в функцию print( )\n",
    "мы передавали строку или переменную - это и есть аргументы. Если при опреде-\n",
    "лении функции вы хотите передавать ей больше одной переменной, но еще не знае-\n",
    "те точно, сколько аргументов у вас будет, можно указать специальный синтаксис\n",
    "*args. Символ * здесь означает, что мы можем передать функции любое количество\n",
    "переменных, а слово args - это своего рода стандартное соглашение, которое ис-\n",
    "пользуется для лучшей читаемости кода. \n",
    "Именованные аргументы - это аргументы, для которых при передаче в функцию\n",
    "указывается не только значение, но и имя (sep=, end=, file= и flush=) Это именованные\n",
    "аргументы, у них есть имя, а справа от символа = указано присвоенное им значение.\n",
    "Параметры функции print( ) :\n",
    "♦ *objects - любое количество любых объектов. Перед выводом все объекты со\n",
    "бираются в строку;\n",
    "♦ sep= ' ' (необязательный) - задает разделитель объектов, если их несколько.\n",
    "Значение по умолчанию - символ пробела, указанный как ' ' ;\n",
    "♦ end= ' \\n ' (необязательный) - определяет, что вывести в конце строки. Значение\n",
    "по умолчанию - символ переноса строки ' \\n ' ;\n",
    "♦ file=sys . stdout (необязательный) - объект с методом write(string). Если этот\n",
    "параметр не указан, будет использоваться sys.stdout по умолчанию, что означает\n",
    "вывод результатов на экран;\n",
    "♦ flush=False (необязательный) - логическое значение, указывающее, будет ли\n",
    "вывод очищен (тrue) или буферизован (False). По умолчанию имеет значение\n",
    "False.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0, 1, 1, 2, 3, 5, 8, 13, "
     ]
    }
   ],
   "source": [
    "# тот же ряд Фибоначчи\n",
    "a_, b_ = 0, 1\n",
    "while a_ < 15:\n",
    "    print(a_, end=\", \")\n",
    "    a_, b_ = b_, a_ + b_"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "3.5.2. Форматированный вывод"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "when 5 is multiplied Ьу 6, the result is 30 .\n"
     ]
    }
   ],
   "source": [
    "a_ = 5\n",
    "b_ = 6\n",
    "a_b_ = 5 * 6\n",
    "print(f\"when {a_} is multiplied Ьу {b_}, the result is {a_b_} .\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Nilabh Nishchhal lives in Mumbai\n"
     ]
    }
   ],
   "source": [
    "# вариант со строками\n",
    "name = \"Nilabh\"\n",
    "lastname = \"Nishchhal\"\n",
    "place = \"Mumbai\"\n",
    "print(f\"{name} {lastname} lives in {place}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "В двух приведенных примерах если вы измените значения переменных, то \n",
    "выходные данные тоже изменятся вместе с ними."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "3.5.3. Простейшая геометрия и print().\n",
    "Нарисуем треугольник, используя только базовый код."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "print (\"     /|\")\n",
    "print (\"    / |\")\n",
    "print (\"   /  |\")\n",
    "print (\"  /   |\")\n",
    "print (\" /    |\")\n",
    "print (\"/_____|\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "3.6. Поиск ошибок.\n",
    "Сообщения об ошибке в Python пишутся довольно подробно\n",
    "и позволяют точно понять, в чем заключается и где находится ошибка.\n",
    "Рассмотрим три основных типа ошибок, которые возникают чаще всего.\n",
    "♦ Синтаксическая ошибка - проблемы с языковыми конструкциями.\n",
    "Ошибка возникает, когда вы пишете код, не соблюдая синтаксис Python. \n",
    "В тексте ошибки указан тип ошибки и место, где найден неверный син-\n",
    "таксис.\n",
    "♦ Ошибка времени выполнения - проблемы с выполнением кода.\n",
    "Ошибка времени выполнения возникает, когда Python понимает саму команду, но\n",
    "при ее выполнении сталкивается с проблемами. Поэтому эта ошибка и называется\n",
    "«времени выполнения», поскольку возникает только после запуска программы.\n",
    "Может возникнуть из-за:\n",
    "- неверно введенное имя переменной или функции;\n",
    "- использование переменной до ее определения;\n",
    "- имя должно было быть заключено в кавычки;\n",
    "- деление на ноль и т.д.\n",
    "♦ Семантическая ошибка - неожиданный результат.\n",
    "Эти ошибки часто бывают вызваны случайным использованием неверных пере\n",
    "менных либо просто неправильными вычислениями. Семантические ошибки -\n",
    "самые сложные в устранении.\n",
    "Дополнительные способы найти ошибку:\n",
    "1. Поиск в Интернете. Лучшее место для поиска ответов - это сайт\n",
    "stackoverflow.com\n",
    "2. Избегать таких случаев. Всегда стоит сначала писать несколько строк кода, а\n",
    "затем выполнять программу. Затем добавлять еще несколько строк кода и снова\n",
    "запускать. \n",
    "3. Промежуточные версии. Следует сохранять промежуточный прогресс в разра-\n",
    "ботке программы каждый раз, когда вы начинаете писать новую часть. Если вы\n",
    "достигли определенного этапа, сделайте резервную копию. Для этого достаточ\n",
    "но выбрать пункт меню Save as и назвать свой файл filename2.py, затем\n",
    "filename3.py и т. д. Если вы работаете с filename7.py и столкнулись с нерешае-\n",
    "мой проблемой, можно просто вернуться к filename6.py. \n",
    "4. Комментарии. Вы можете попытаться закомментировать проблемный участок\n",
    "кода, чтобы посмотреть, сохранится ли проблема. \n",
    "5. Все сначала. Когда ничего не помогает, вы можете начать писать заново, с \n",
    "нового пустого файла. Затем скопируйте и вставьте небольшие фрагменты кода из\n",
    "старого файла по одному. Каждый раз, добавляя новый раздел, запускайте свою\n",
    "программу и проверяйте, не появилась ли проблема.\n",
    "\n",
    "3.7. Резюме\n",
    "1. Знакомство со Spyder IDE и Jupyter Notebook. \n",
    "2. Начала работу с Python и научилась использовать его в качестве калькулятора. \n",
    "3. Работа со строками.\n",
    "4. Узнала, что такое выражения, операторы и переменные.\n",
    "5. Написала многострочную программу и изучила несколько принципов написания\n",
    "кода на Python, таких как множественное присваивание, отступы, цикл и \n",
    "вывод результата. \n",
    "6. Изучила, как работает функция print(), и познакомилась с двумя понятиями, такими как\n",
    "аргументы и именованные аргументы. \n",
    "7. Рассмотрела некоторые ошибки и что нужно делать при их вонзникновении.\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "1. В чем преимущества редактора Spyder IDE по сравнению с простым текстовым\n",
    "редактором?\n",
    "Ответ:\n",
    "Функционал IDE гораздо шире и включает в себя, например, нумерацию строк,\n",
    "выделение синтаксиса (ключевые слова в синтаксисе подсвечиваются цветом),\n",
    "функции автозаполнения и многое другое. В этом многоязычном редакторе есть\n",
    "возможность эффективно работать с функциями и классами, пользоваться\n",
    "инструментами анализа кода, автоматическим завершением кода, \n",
    "горизонтальным/вертикальным разделением и переходом к определению объекта.\n",
    "2. Как в Python пишутся операторы сложения, вычитания, умножения и деления?\n",
    "Ответ:\n",
    "+ , -, *, /.\n",
    "3. В чем разница между операторами * и **? Что они означают в Python?\n",
    "Ответ:\n",
    "Оператор * - умножение; оператор ** - возведение в степень.\n",
    "4. Что такое выражения в Python? Зачем они нужны?\n",
    "Ответ:\n",
    "Выражение - это совокупность значений, переменных и операторов. Нужны они \n",
    "в случае, когда необходимо произвести какие-либо операции и определить \n",
    "результат.\n",
    "5 . Что такое переменная? Как присвоить переменной какое-либо значение?\n",
    "Ответ:\n",
    "Переменная - это некоторое имя, связанное со значением. Присвоить переменной\n",
    "какое-либо значение можно через оператор присваивания, при этом переменная\n",
    "будет лишь ссылатся на значение, которое ей присвоено.\n",
    "6. Можно ли в Python дать переменной имя import? Обоснуйте ответ.\n",
    "Ответ:\n",
    "Нельзя, это значение зарезервировано.\n",
    "7. В Python имена math, мath эквивалентны МАТН. Так ли это на самом деле? \n",
    "Обоснуйте свой ответ.\n",
    "Ответ:\n",
    "Неэквивалентны. В python важен регистр написания. \n",
    "8. Каким образом можно группировать выражения в Python?\n",
    "Ответ:\n",
    "()\n",
    "9. В чем разница между синтаксической ошибкой и семантической ошибкой?\n",
    "Ответ:\n",
    "Семантические или логические ошибки - это проблемы с самим построением\n",
    "вашей программы. А Синтаксическая ошибка возникает, когда вы пишете код,\n",
    "не соблюдая синтаксис Python.\n",
    "1 0. Каково значение по умолчанию именованных аргументов sep и end в синтаксисе\n",
    "функции print()?\n",
    "Ответ:\n",
    "разделение и окончание\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "3.8.2. Правда или ложь\n",
    "1. Простое деление четного числа на 2 вернет объект типа int ( целое число).\n",
    "ЛОЖЬ\n",
    "2. Положительный индекс строки начинается с О, а отрицательный индекс начина-\n",
    "ется с - 1.\n",
    "ПРАВДА\n",
    "3. Строки Python можно изменять, или, другими словами, они изменяемы.\n",
    "ЛОЖЬ\n",
    "4. Dream теаm - это допустимое имя переменной в Python.\n",
    "ЛОЖЬ\n",
    "5. В Python можно дать переменной имя lambda.\n",
    "ЛОЖЬ\n",
    "6. Выражения в Python завершаются точкой ( . ).\n",
    "ЛОЖЬ\n",
    "7. Выражения а = 25 и а == 25 в Python эквивалентны.\n",
    "ЛОЖЬ\n",
    "8. Вывод выражения с использованием функции print ( ) - это не то же самое, что\n",
    "вычисление этого выражения.\n",
    "ПРАВДА\n",
    "9. Семантические ошибки являются подвидом синтаксических ошибок.\n",
    "ЛОЖЬ\n",
    "10. Деление на ноль вызывает ошибку времени выполнения\n",
    "ПРАВДА"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "3.8.З. Практические задания\n",
    "1 . Напишите программу, в которой бы соединялись ваши имя и фамилия.\n",
    "Между ними должен быть пробел."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Ekaterina Zyryanova\n"
     ]
    }
   ],
   "source": [
    "my_name = \"Ekaterina\" + \" \" + \"Zyryanova\"\n",
    "print(my_name)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "2. Прямоугольник имеет длину l и высоту h. Напишите код для \n",
    "вычисления площади прямоугольника с высотой 8 и длиной 23. В коде\n",
    "должно быть присвоение значений переменным l и h, чтобы один и тот\n",
    "же код можно было использовать повторно. Для вычисления площади\n",
    "прямоугольника нужно его длину умножить на высоту."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "184"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "l_ = 23\n",
    "h_ = 8\n",
    "S_ = l_ * h_\n",
    "S_"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "3 . Чему равен квадрат числа 32 и куб числа 27? Напишите оператор, который \n",
    "ответит на этот вопрос.\n",
    "Ответ: ** 2 и ** 3"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "4. Напишите приведенное ниже уравнение на Python. Присвойте числовые значе\n",
    "ния переменным и вычислите результат.\n",
    "(а + Ь)2 = a2 + Ь2 + 2аЬ"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "900\n"
     ]
    }
   ],
   "source": [
    "a_ = 5\n",
    "b_ = 25\n",
    "res = a_**2 + b_**2 + 2 * (a_ * b_)\n",
    "print(res)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "5 . Найдите длину своего имени, написав однострочный код на Python."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "9\n"
     ]
    }
   ],
   "source": [
    "name = \"Ekaterina\"\n",
    "print(len(name))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "6. Нарисуйте прямоугольник, используя функцию print ( ) "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "print(' ' + '_' * 6 + ' ')\n",
    "print('|' + ' ' * 6 + '|')\n",
    "print('|' + ' ' * 6 + '|')\n",
    "print('|' + ' ' * 6 + '|')\n",
    "print('|' + ' ' * 6 + '|')\n",
    "print('|' + '_' * 6 + '|')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "7. Нарисуйте букву «Р» с помощью простейшей геометрии и функции print ( ) "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "print(' ' + '_' * 4 + ' ')\n",
    "print('|' + ' ' * 4 + '\\\\')\n",
    "print('|' + ' ' * 4 + '|')\n",
    "print('|' + '_' * 4 + '/')\n",
    "print('|')\n",
    "print('|')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "8. Создайте переменную Name и присвойте ей свое имя. Переменной Age присвойте\n",
    "свой возраст. Затем напишите оператор print ( ) , который выведет текст «меня\n",
    "зовут Name, а мой возраст - Age», с подставленными значениями ваших перемен\n",
    "ных. Значения Name и Age должны быть строкой и числом соответственно."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "My name is Ekaterina, my age - 42\n"
     ]
    }
   ],
   "source": [
    "name = \"Ekaterina\"\n",
    "age = 42\n",
    "print(f\"My name is {name}, my age - {age}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "9. Исправьте синтаксическую ошибку в следующих строках кода:\n",
    "words = [ cat, window, defenestrate]\n",
    "for w in words :\n",
    "\tprint (w, len (w) )"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "cat 3\n",
      "window 6\n",
      "defenestrate 12\n"
     ]
    }
   ],
   "source": [
    "words = [\"cat\", \"window\", \"defenestrate\"]\n",
    "for w_ in words:\n",
    "    print(w_, len(w_))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "10. Исправьте синтаксическую ошибку в следующих строках кода:\n",
    "а, Ь = О, 1\n",
    "while а < 15 :\n",
    "\tprint(a, end= ' , ' )\n",
    "\tа, Ь = Ь, а + Ь"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0, 1, 1, 2, 3, 5, 8, 13, "
     ]
    }
   ],
   "source": [
    "a_, b_ = 0, 1\n",
    "while a_ < 15:\n",
    "    print(a_, end=\", \")\n",
    "    a_, b_ = b_, a_ + b_"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
