"""Ошибки и обработка исключений."""

from datetime import datetime
from typing import Optional, Union

# 12.1. Ошибки и исключения
# Программа на Python останавливается сразу, как только обнаруживает ошибку.
# Существуют (как минимум) два различных типа ошибок: синтаксические ошибки
# и исключения

# 12.1.1. Синтаксические ошибки
#

# ![image.png](attachment:image.png)

# При вызове функции в начале было две открывающиеся круглые
# скобки, а в конце - только одна закрывающая? Эта мелкая опечатки вызвала
# ошибку в простейшем коде - SyntaxError : unexpected EOF while parsing.

# ![image.png](attachment:image.png)

# Синтаксический анализатор выводит строку с ошибкой и с помощью маленькой
# стрелки v указывает на первое проблемное место в строке. Ошибка возникла
# (или, по крайней мере, обнаружена) в символе перед стрелкой: в нашем
# случае перед функцией print ( ) , поскольку перед ней отсутствует двоеточие
# ( : ). Также в тексте ошибки выводится имя файла и номер строки, поэтому вы
# знаете, где искать проблему в скрипте.

# 12.1.2. Исключения
# Даже если оператор или выражение написаны синтаксически верно, они могут вы
# звать ошибку при попытке их выполнить. Ошибки, обнаруженные во время выпол-
# нения, называются исключениями.
# Большинство исключений не являются фатальными. Но если исключения не
# обрабатываются, то это приводит к появлению сообщений об ошибках.

# ![image.png](attachment:image.png)

# Вместо того, чтобы показывать ошибку в общем виде, Python подробно рассказы
# вает, какой тип исключения был обнаружен. В последней строке сообщений об
# ошибке поясняется, что произошло. Исключения бывают разных типов, и тип
# исключения выводится в сообщении об ошибке. В данных примерах это
# ZeroDivisionError, NameError и: TypeError
# Непосредственно перед текстом ошибки выводится фрагмент кода, в котором про
# изошло исключение, в виде обратной трассировки стека. Как правило, это список
# последних вызываемых строк кода, и в нем не содержатся строки, полученные из
# стандартного ввода.

# 12.2. Вызов исключений
# 12.2.1. Оператор raise
# В Python есть различные встроенные исключения, а также можно создавать
# пользовательские исключения. Оператор raise позволяет программисту сгенерировать
# встроенное исключение или вызвать свое собственное.

# ![image.png](attachment:image.png)

# Обратите внимание на то, что в приведенных выше примерах оператор raise наме-
# ренно вызывает исключение, причем не любое, а с явно указанным текстом ошиб-
# ки. Единственный аргумент оператора raise - вызываемое исключение. Этот
# аргумент должен быть либо экземпляром исключения, либо классом исключения
# (производным от Exception).

# 12.2.2. Исключение AssertionError
# Вместо того, чтобы ждать, пока программа сломается где-то при выполнении,
# мы можем заранее использовать утверждения. Мы словно «утверждаем» с помощью
# оператора assert, что здесь должно выполняться определенное условие. Если
# условие, которое мы указали, оказывается истинным, программа продолжает вы
# полнение. Если условие окажется ложным, программа сгенерирует исключение
# AssertionError.

# ![image.png](attachment:image.png)

# 12.З. Обработка исключений
# 12.3.1 . Операторы try и except

# Конструкция try-except в Python используется для перехвата и обработки исключе
# ний (рис. 1 2. 1 ). Python выполняет блок try как обычную часть программы. Код,
# следующий за оператором except, является ответом программы на любое исключе
# ние, которое могло возникуть в блоке try.

# ![image.png](attachment:image.png)

# Как мы видели ранее, Python выдает исключение, если синтаксически правильный
# код генерирует ошибку. Если исключение не обработать, оно приведет к сбою про-
# граммы. То, как ваша программа реагирует на исключения, определяется в блоке
# except.
# Конструкция try-except работает следующим образом:
# 1 . Сначала выполняется блок try (инструкции между ключевыми словами try
# И except).
# 2 . Если не возникает исключения, блок except пропускается и выполнение завер-
# шается.
# 3. Если во время выполнения блока try возникает исключение, остальная часть
# блока пропускается. Затем, если тип возникшего исключения соответствует ука
# занному после ключевого слова except, выполняется блок except, а затем про
# должает выполняться следующий код за пределами блока.
# 4. Если возникает исключение, отличное от указанного в блоке except, оно переда-
# ется во внешние операторы try. Если исключение так и не будет перехвачено,
# это означает, что программа встретила необработанное исключение и ее выпол-
# нение останавливается с сообщением об ошибке.
# После оператора try может быть более одного блока except, в которых можно обра-
# ботать разные исключения. В любом случае будет выполнено не более одного бло-
# ка except. При этом обрабатывают только те исключения, которые возникли в соот-
# ветствующем блоке try, но не в других блоках except того же оператора try.
# В блоке except можно указать несколько исключений в виде кортежа, например:
# except ( RuntimeError, TypeError, NarneError) :
# СОВЕТ
# Обработка одного базового исключения Exception «скрывает» все ошибки, даже со-
# вершенно неожиданные. Поэтому следует избегать обработки только базовых исклю-
# чений в программах на Python. Вместо этого лучше перехватывать более конкретные
# типы исключений.

# 12.3.2. Блок else
# У конструкции try-except есть необязательный блок else, который может следовать
# после всех блоков except. В нем указывается код, который должен выполниться,
# если блок try не вызвал исключения.
# Другими словами, используя блок else, вы говорите программе выполнить опреде-
# ленный код только в случае отсутствия исключений. Использование блока else
# лучше, чем добавление дополнительного кода в блок try, поскольку позволяет из
# бежать случайного перехвата исключения, которое возникло не в текущем блоке
# try-except.

# ![image.png](attachment:image.png)

# Обработчики исключений перехватывают исключения не только в том случае, если
# они возникли в самом коде блока try, но и когда исключения возникают внутри
# функций, которые вызываются (даже косвенно) в блоке try.

# 12.4. Завершающий блок
# У оператора try есть еще один необязательный блок finally, предназначенный для
# выполнения какой-либо очистки, которую требуется выполнить в любом случае.

# Если блок finally добавлен, он выполнится напоследок перед выходом из всей кон
# струкции try (рис. 1 2.3). Блок finally запускается всегда, независимо от того,
# возникло ли исключении в блоке try или нет.

# ![image.png](attachment:image.png)

# Приведем несколько более сложных случаев.
# ♦ Если во время выполнения блока try возникает исключение, оно может быть
# обработано с помощью блока except. Если исключение не обрабатывается бло-
# ком except, исключение повторно вызывается после выполнения блока finally.
# ♦ Исключение могло произойти во время выполнения блока except или else.
# В этом случае, опять же, исключение повторно возникает после выполнения
# блока finally.
# ♦ Если в блоке try встретился оператора break, continue или return, блок
# finally будет выполнен непосредственно перед выполнением оператора break,
#  continue ИЛИ return.
# ♦ Если блок finally содержит оператор return, то вернется значение из
# оператора return блока finally, а не значение из оператора return блока
# try.

# 12.5. Резюме
#
# Я узнала, что:
# 1. Оператор raise позволяет в любой момент вызвать исключение.
# 2. Оператор assert позволяет проверить, выполняется ли определенное условие.
# Если условие не выполняется, генерируется исключение.
# 3. Весь код в блоке try последовательно выполняется, пока программа не обнару
# жит исключение.
# 4. Если в блоке try возникнет исключение, оно будет обработано в соответствую
# щем блоке except.
# 5. Блок else позволяет писать код, который будет выполнен только в том случае,
# если в блоке try не было никаких исключений.
# 6. Блок finally содержит код, который должен выполняться всегда, независимо от
# того, возникло ли исключение.

# 12.6. Упражнения
#
# 12.6.1 . Ответьте на вопросы
#
# 1. Когда возникает ошибка TypeError?
# Ответ: Ошибка TypeError в Python возникает, когда выполняется операция или
# вызывается функция, которая не поддерживает операндов указанного типа.
# - операция между несовместимыми типами;
# - вызов функции с неподходящими аргументами;
# - использование недопустимых индексов или методов для объекта;
# - попытка выполнить операцию с объектом неподходящего типа;
# - неправильный тип для передачи в функцию.
# 2. Опишите синтаксис оператора raise.
# Ответ: raise [Exception [, args [, traceback]]]
# Exception — класс исключения (например, ValueError, TypeError и т.д.)
# args — дополнительные аргументы, которые передаются в конструктор исключения.
# traceback — необязательный аргумент, который используется для передачи
# объекта traceback.
# Пример: raise ValueError("Некорректное значение")
# 3. Какие бывают исключения? Как они обрабатываются в Python?
# Ответ: Исключения бывают как встроенные, так и пользовательские. Встроенные
# наследуются от базового класса BaseException. Самые распросраненные из них:
# SyntaxError — ошибка синтаксиса, возникающая, когда Python не может правильно
# интерпретировать код.
# TypeError — ошибка типа, возникает при попытке выполнить операцию с объектами
# несовместимых типов.
# ValueError — ошибка, связанная с передачей аргумента неправильного значения.
# IndexError — ошибка выхода за пределы индекса в последовательности.
# KeyError — ошибка, возникающая при обращении к несуществующему ключу в словаре.
# AttributeError — ошибка, возникающая при попытке доступа к атрибуту объекта,
# который не существует.
# NameError — ошибка, когда имя переменной или функции не определено.
# ImportError — ошибка импорта, возникающая при попытке импорта модуля, который
# не существует или не доступен.
# Обработка исключений в Python осуществляется с помощью блока try-except. Блоки
# else и finally позволяют дополнительно контролировать выполнение программы при
# возникновении ошибок.
# 4. Зачем нужен блок finally?
# Ответ: Гарантированное выполнение: Код в блоке finally всегда выполняется, даже
# если в блоке try произошло исключение или было вызвано return.
# 5. Когда и зачем использовать оператор raise?
# Ответ: Оператор raise в Python используется для возбуждения исключений (ошибок)
# вручную. Этот оператор позволяет вам создавать собственные ошибки в нужный
# момент, чтобы сигнализировать о проблемах в программе и передать управление
# блокам обработки исключений (например, в try-except).
# 6. Напишите синтаксис операторов try и except.
# Ответ: try:
#     # Код, который может вызвать исключение
# except SomeException as e:
#     # Обработка исключения
# 7. Когда можно использовать оператор else при обработке исключений?
# Ответ: Оператор else при обработке исключений в Python используется в блоках
# try-except и выполняется только в том случае, если в блоке try не было вызвано
# исключение. Это позволяет удобно структурировать код, который должен выполняться,
# если ошибки не произошло, и разделить его от кода, который работает с ошибками
# в блоках except.

# 12.6.2. Правда или ложь
# 1. Программа Python завершается при обнаружении ошибки.
# ПРАВДА
# 2. Ошибка SyntaxError возникает, когда мы делаем в коде орфографические ошибки.
# ПРАВДА
# 3. При правильном синтаксисе кода никаких других ошибок возникнуть не может.
# ЛОЖЬ
# 4. Оператор raise вызывает указанное исключение.
# ПРАВДА
# 5. Блок try перехватывает исключение.
# ПРАВДА
# 6. Блок except тоже используется для перехвата исключений.
# ЛОЖЬ
# 7. В блоке try может быть более одного блока except.
# ПРАВДА
# 8. Перехват исключений не связан с рисками.
# ЛОЖЬ
# 9. Блок else обязательно следует за блоком try.
# ЛОЖЬ
# 10. Блок finally выполняется независимо от того, возникло ли в блоке try
# исключение.
# ПРАВДА

# 12.6.3. Практические задания
# 1. Напишите функцию с именем oops(), которая явно вызывает исключение
# IndexError при вызове. Затем напишите другую функцию, которая вызывает
# oops ( ) внутри конструкции try-except и перехватывает ошибку. Что произойдет,
# если в функции oops( ) вместо IndexError будет вызываться KeyError?
# ОТВЕТ: В этом случае исключение KeyError не будет перехвачено в блоке except
# IndexError, потому что тип исключения не совпадает. В результате возникнет
# ошибка в процессе выполнения.


def oops() -> None:
    """Raise an IndexError with a custom message."""
    raise IndexError("Это ошибка индекса!")


def handle_oops() -> None:
    """Call the oops function, which raises an IndexError.

    and handles the exception.
    """
    try:
        oops()
    except IndexError as e:
        print(f"Перехвачено исключение: {e}")


handle_oops()


# 2. Напишите функцию нахождения среднего значения списка чисел. Ваша функция
# должна иметь возможность обрабатывать пустой список, а также список, содер-
# жащий строку.


def average(numbers: list[Union[int, float]]) -> Optional[float]:
    """Calculate the average of a list of numbers, ignoring.

    non-numeric values.
    """
    if not numbers:
        return None
    valid_numbers = [num for num in numbers if isinstance(num, (int, float))]

    if not valid_numbers:
        raise ValueError("Список не содержит числовых значений.")

    return sum(valid_numbers) / len(valid_numbers)


# 3 . Напишите программу, принимающую дату от пол14ователя в виде дня, месяца и
# года и вызывающую соответствующие ошибки, если передано недопустимое
# значение. Выводите сообщения об ошибке, пока пользователь не введет пра
# вильные значения.


def get_valid_date() -> datetime:
    """Prompt the user to enter a valid date (day, month, year)

    and returns a corresponding datetime object.
    """
    while True:
        try:

            day = int(input("Введите день (1-31): "))
            month = int(input("Введите месяц (1-12): "))
            year = int(input("Введите год (например, 2024): "))

            date_str = f"{year}-{month:02d}-{day:02d}"
            date = datetime.strptime(date_str, "%Y-%m-%d")

            print(f"Вы ввели правильную дату: {date.strftime('%d-%m-%Y')}")
            return date

        except ValueError:
            print("Ошибка: введены некорректные данные. Попробуйте снова.")
        except SyntaxError as e:
            print(f"Ошибка: {e}. Попробуйте снова.")


get_valid_date()


# 4. Создайте класс Person для хранения личной информации (по вашему выбору)
# о человеке. Убедитесь, что ввод некорректных данных обрабатывается должным
# образом.


class Person:
    """Class for keeping private information."""

    def __init__(self, name: str, age: int) -> None:
        """Initialize a new Person object with a given name and age.

        Args:
            name (str): The name of the person.
            age (int): The age of the person.
        """
        self.name = name
        self.age = age

    def __str__(self) -> str:
        """Return a string representation of the person object."""
        return f"Имя: {self.name}\nВозраст: {self.age}"

    def validate_age(self) -> None:
        """Validate the age of the person to ensure it is not negative.

        Raises:
            ValueError: If the person's age is negative.
        """
        if self.age < 0:
            raise ValueError("Возраст не может быть отрицательным.")

    @classmethod
    def create_person(cls) -> "Person":
        """Prompt the user to enter a name and age to create a Person object.

        This method will keep asking the user for valid input until

        it is received.
        """
        while True:
            try:
                name = input("Введите имя: ").strip()
                if not name:
                    raise ValueError("Имя не может быть пустым.")

                age = int(input("Введите возраст: ").strip())

                # Проверка корректности возраста
                if age < 0:
                    raise ValueError("Возраст не может быть отрицательным.")

                new_person = cls(name, age)

                # Проверяем все данные
                new_person.validate_age()

                return new_person
            except ValueError as e:
                print(f"Ошибка: {e}. Пожалуйста, введите корректные данные.")


# Создаем объект Person с помощью метода create_person
person = Person.create_person()
print(person)
